#' specifyPopulation function
#'
#' Function to specify the species and population characteristics. This would not need to be a function, but this way all definitions are in one place
#'
#' @param bsp A list of objects to combine with the species and population parameters. bsp is short for breeding sheme parameters
#' @param ctrlFileName The name of the text file with parameter values specifying the breeding population. Must include the path to the file. If NULL a toy example simulation will be set up
#' @return A list containing objects that specify the species and population characteristics.
#'
#' @details Call this function before beginning the simulation
#'
#' @examples
#' bsp <- specifyPopulation(bsp)
#'
#' @export
specifyPopulation <- function(bsp=NULL, ctrlFileName=NULL){
  if (is.null(ctrlFileName)){ # NULL control file: make toy example
    # Species characteristics
    nChr <- 2 # Number of chromosomes
    # Population characteristics
    effPopSize <- 100 # Effective size of population generating founders
    segSites <- 20 # Number of segregating sites per chromosome
    nQTL <- 5 # Number of QTL per chromosome
    nSNP <- 5 # Number of observed SNP per chromosome
    genVar <- 40 # Initial genetic variance
    gxeVar <- 30 # Initial genetic variance
    meanDD <- 0.8; varDD <- 0.01 # Mean and variance of dominance degree
    bspNew <- mget(setdiff(ls(), "bspNew"))
    #END no control file
  } else{
    parmNames <- c("nChr", "effPopSize", "segSites", "nQTL", "nSNP", "genVar", "gxeVar", "meanDD", "varDD")
    bspNew <- readControlFile(ctrlFileName, parmNames)
  }
  bsp <- c(bsp, bspNew)
  return(bsp)
}

#' specifyPipeline function
#'
#' function specify the product pipeline. This would not need to be a function, but this way all definitions are in one place
#'
#' @param bsp A list of objects to combine with the pipeline parameters. bsp is short for breeding sheme parameters
#' @param ctrlFileName The name of the text file with parameter values controling the simulation. Must include the path to the file. If NULL a toy example simulation will be set up
#' @return A list containing objects that specify the product pipeline. This list will determine the number of lists in the records object
#'
#' @details Call this function before beginning the simulation
#'
#' @examples
#' bsp <- specifyPipeline()
#'
#' @export
specifyPipeline <- function(bsp=NULL, ctrlFileName=NULL){
  if (is.null(ctrlFileName)){ # NULL control file: make toy example
    nStages <- 4 # Number of stages in the product pipeline
    stageNames <- c("SDN", "CET", "PYT", "AYT")
    
    stageToGenotype <- "SDN"
    
    nParents <- 20 # Number of parents in the crossing nursery
    nCrosses <- 20 # Number of crosses entering the pipeline
    nProgeny <- 10 # Number of progeny per cross
    # Don't use optimum contributions in simple default. Define other parms in case
    useOptContrib <- FALSE
    nCandOptCont <- 100
    targetEffPopSize <- 30
    # Number of number of entries in each stage
    nEntries <- c(nCrosses*nProgeny, 60, 20, 10)
    nReps <- c(1, 1, 2, 2) # Number of reps used in each stage
    nLocs <- c(1, 2, 2, 3) # Number of locations used in each stage
    # Number of checks used in each stage
    # Checks are replicated the same as experimental entries
    nChks <- c(2, 1, 1, 1)
    entryToChkRatio <- c(20, 20, 20, 10)
    # Error variances estimated from historical data
    # 200 for SDN is a guess
    errVars <- c(200, 146, 82, 40)
    
    # Use rapid visual selection to move pre-seedlings to SDN
    phenoF1toStage1 <- FALSE
    errVarPreStage1 <- 500
    
    names(nEntries) <- names(nChks) <- names(nReps) <- names(errVars) <- stageNames
    useCurrentPhenoTrain <- FALSE
    nCyclesToKeepRecords <- 5 # How many cycles to keep records
    # Function to advance individuals from one stage to the next
    selCritPipeAdv <- selCritIID
    selCritPopImprov <- selCritIID
    bspNew <- mget(setdiff(ls(), "bspNew"))
    #END no control file
  } else{
    parmNames <- c("nStages", "stageNames", "stageToGenotype", "nParents", "nCrosses", "nProgeny", "useOptContrib", "nCandOptCont", "targetEffPopSize", "nEntries", "nReps", "nLocs", "nChks", "entryToChkRatio", "errVars", "phenoF1toStage1", "errVarPreStage1", "useCurrentPhenoTrain", "nCyclesToKeepRecords", "selCritPipeAdv", "selCritPopImprov")
    # Any parameter not specified will have a default set in calcDerivedParms
    bspNew <- readControlFile(ctrlFileName, parmNames)
  }
  bsp <- c(bsp, bspNew)
  bsp <- calcDerivedParms(bsp)
  return(bsp)
}

#' specifyCosts function
#'
#' Function to specify the species and population characteristics. This would not need to be a function, but this way all definitions are in one place
#'
#' @param bsp A list of objects to combine with the species and population parameters. bsp is short for breeding sheme parameters
#' @param ctrlFileName The name of the text file with parameter values specifying the breeding costs. Must include the path to the file. If NULL a toy example simulation will be set up
#' @return A list containing objects that specify the species and population characteristics.
#'
#' @details Call this function before beginning the simulation
#'
#' @examples
#' bsp <- specifyCosts(bsp)
#'
#' @export
specifyCosts <- function(bsp=NULL, ctrlFileName=NULL){
  if (is.null(ctrlFileName)){ # NULL control file: make toy example
    # Plot costs
    plotCosts <- c(1, 8, 14, 32)
    # Per location cost
    perLocationCost <- 1000
    # Crossing cost
    crossingCost <- 0.2
    # Genotyping cost
    qcGenoCost <- 1.5
    wholeGenomeCost <- 10
    bspNew <- mget(setdiff(ls(), "bspNew"))
    #END no control file
  } else{
    parmNames <- c("plotCosts", "perLocationCost", "crossingCost", "qcGenoCost", "wholeGenomeCost")
    bspNew <- readControlFile(ctrlFileName, parmNames)
  }
  names(bspNew$plotCosts) <- bsp$stageNames
  bsp <- c(bsp, bspNew)
  # Calculate the program yearly cost
  # Assumptions
  # 1. Every new progeny is both QC and whole-genome genotyped. The number of
  # new progeny is nCrosses*nProgeny, so the cost is
  # nCrosses*nProgeny*(crossingCost + qcGenoCost + wholeGenomeCost)
  # 2. The number of plots in each trial is nEntries*nReps + nChks*chkReps so the cost
  # of the trial is (nEntries*nReps + nChks*chkReps)*plotCost*nLocs
  # NOTE for develCosts not accounting for number of rapid cycles
  develCosts <- bsp$nCrosses * bsp$nProgeny * bsp$crossingCost
  
  if (is.null(bsp$stageToGenotype) | bsp$stageToGenotype == "F1"){
    nGeno <- bsp$nCrosses * bsp$nProgeny
  } else{
    nGeno <- bsp$nEntries[bsp$stageToGenotype]
  }
  genotypingCosts <- nGeno * (bsp$qcGenoCost + bsp$wholeGenomeCost)
  
  trialCosts <- ((bsp$nEntries * bsp$nReps + bsp$nChks * bsp$chkReps) * bsp$nLocs) %*% bsp$plotCost
  
  locationCosts <- max(bsp$nLocs) * bsp$perLocationCost
  
  totalCosts <- develCosts + genotypingCosts + trialCosts + locationCosts
  return(c(bsp, c(develCosts=develCosts, genotypingCosts=genotypingCosts, locationCosts=locationCosts, trialCosts=trialCosts, totalCosts=totalCosts)))
}

#' specifyBSP function
#'
#' Function to manually specify a breeding scheme parameters (bsp) object in R, rather than using a control file.
#' Currently does not handle costs. For costs (for now), run specifyCosts() on this.
#' Ideally this is useful for programmatically varying breeding schemes.
#'
#' @param schemeDF data.frame columns: stageNames, nReps, nLocs, nChks, nEntries, entryToChkRatio, errVars
#' @param nParents integer number of parents to cross
#' @param nCrosses integer how many crosses to make
#' @param nProgeny integer how many progeny per cross
#' @param useOptContrib logical whether to use optimal contributions
#' @param nCandOptCont integer how many candidates to consider for opt contrib
#' @param targetEffPopSize numeric target effective population size for OC
#' @param useCurrentPhenoTrain logical whether to use phenotypes for parent sel
#' @param nCyclesToKeepRecords integer eliminate data on cycles above this num
#' @param selCritPipeAdv function used to determine selection criterion for pipe
#' @param selCritPopImprov function used to determine sel crit for pop improv
#' @param nChr integer number of chromosomes for the species
#' @param effPopSize numeric historic effective population size for the species
#' @param segSites integer number of sites segregating per chromosome
#' @param nQTL integer number of loci affecting the trait per chromosome
#' @param nSNP integer number of observed SNPs per chromosome
#' @param genVar numeric genetic variance of the founders
#' @param gxeVar numeric genotype by environment variance of the founders
#' @param meanDD numeric mean dominance deviation. Set to zero for additive
#' @param varDD numeric variance across loci of their dominance deviation
#'
#' @return a named list of of the parameters to specify a breeding scheme simulation
#'
#' @details All arguments are exactly as specified in the control files. Main exception is schemeDF, which is just a tibble() or data.frame version of the set of bsp arguments which are vectors (giving values for each breeding stage). Columns must have names exactly as in the corresponding arguments in control file: stageNames, nReps, nLocs, nChks, nEntries, entryToChkRatio, errVars
#'
#' @examples
#' schemeDF <- tibble(stageNames=c("SDN", "CET", "PYT"),
#'                  nReps=c(1, 1, 2),
#'                  nLocs=c(1, 1, 2),
#'                  nChks=c(1, 1, 2),
#'                  nEntries=c(100, 50, 20),
#'                  entryToChkRatio=c(50, 20, 10),
#'                  errVars=c(150,75,40))
#' bsp <- specifyBSP(schemeDF,nParents = 10, nCrosses = 10, nProgeny = 10,
#'                 useOptContrib = FALSE,
#'                 useCurrentPhenoTrain = TRUE,
#'                 nCyclesToKeepRecords = 1,
#'                 selCritPipeAdv = selCritGRM,
#'                 selCritPopImprov = selCritGRM,
#'                 nChr = 2,effPopSize = 50,
#'                 segSites = 100, nQTL = 5, nSNP = 10,
#'                 genVar = 50, gxeVar = 0, meanDD = 0.05, varDD = 0.25)
#' test <- runBreedingScheme(replication = 1,nCycles = 1,
#'                         initializeFunc = initFuncADChk,
#'                         productPipeline = prodPipeFncChk,
#'                         populationImprovement = popImprov1Cyc,
#'                         bsp = bsp)
#' @export
specifyBSP <- function(schemeDF,
                     nParents,nCrosses,nProgeny,
                     useOptContrib=FALSE,nCandOptCont=NULL,targetEffPopSize=NULL, # if useOptContrib=TRUE, must specify these args
                     useCurrentPhenoTrain=TRUE,
                     nCyclesToKeepRecords,
                     selCritPipeAdv,selCritPopImprov,
                     nChr,effPopSize,
                     segSites,nQTL,nSNP,genVar,gxeVar,meanDD,varDD){
  bspNew <- list()
  bspNew[["nStages"]] <- nrow(schemeDF)
  bspNew[["stageNames"]] <- schemeDF$stageNames
  bspNew[["nReps"]] <- schemeDF$nReps %>% `names <- `(bspNew$stageNames)
  bspNew[["nLocs"]] <- schemeDF$nLocs %>% `names <- `(bspNew$stageNames)
  bspNew[["nChks"]] <- schemeDF$nChks %>% `names <- `(bspNew$stageNames)
  bspNew[["nEntries"]] <- schemeDF$nEntries %>% `names <- `(bspNew$stageNames)
  bspNew[["entryToChkRatio"]] <- schemeDF$entryToChkRatio %>% `names <- `(bspNew$stageNames)
  bspNew[["errVars"]] <- schemeDF$errVars %>% `names <- `(bspNew$stageNames)
  bspNew[["nParents"]] <- nParents
  bspNew[["nCrosses"]] <- nCrosses
  bspNew[["nProgeny"]] <- nProgeny
  bspNew[["useOptContrib"]] <- useOptContrib # if setting this true, there are other arguments that are needed
  bspNew[["useCurrentPhenoTrain"]] <- useCurrentPhenoTrain
  bspNew[["nCyclesToKeepRecords"]] <- nCyclesToKeepRecords
  bspNew[["selCritPipeAdv"]] <- selCritPipeAdv
  bspNew[["selCritPopImprov"]] <- selCritPopImprov
  bspNew[["nChr"]] <- nChr
  bspNew[["effPopSize"]] <- effPopSize
  bspNew[["segSites"]] <- segSites
  bspNew[["nQTL"]] <- nQTL
  bspNew[["nSNP"]] <- nSNP
  bspNew[["genVar"]] <- genVar
  bspNew[["gxeVar"]] <- gxeVar
  bspNew[["meanDD"]] <- meanDD
  bspNew[["varDD"]] <- varDD

  bspNew <- calcDerivedParms(bspNew)
  return(bspNew) 
}

#' calcDerivedParms function
#'
#' Once you have read in parameters from a control file, or set them yourself, there are still a few derived parameters that are needed.  This function calculates them.
#'
#' @param bsp A list. bsp is short for breeding sheme parameters.
#' @return A list bsp that extends the input with a few derived parameters
#'
#' @details This function is only called internally by other functions used to specify the pipeline
#'
#' Should have default if not specified
#' DONE stageToGenotype=SDN
#' DONE useOptContrib=FALSE, 
#' DONE nCandOptCont=nEntries[1], targetEffPopSize=nParents
#' DONE nChks=0, entryToChkRatio=0
#' DONE phenoF1toStage1=FALSE, errVarPreStage1=genoVar*20
#' DONE useCurrentPhenoTrain=FALSE
#' DONE nCyclesToKeepRecords=5
#' DONE selCritPipeAdv=selCritPopImprov=selCritIID
calcDerivedParms <- function(bsp){
  # Prevent some errors having to do with inconsistent parameters
  if (bsp$nSNP + bsp$nQTL >= bsp$segSites){
    print("The number of segregating sites (segSites) has to be greater than the number of SNPs (nSNP) and the number of QTL (nQTL). segSites has been set to nSNP + nQTL + 1")
    bsp$segSites <- bsp$nSNP + bsp$nQTL + 1
  }
  
  # Some parms have to be logical
  makeLogical <- function(parm){
    if (is.null(parm)) parm <- FALSE else parm <- as.logical(parm)
    return(parm)
  }
  bsp$useCurrentPhenoTrain <- makeLogical(bsp$useCurrentPhenoTrain)
  bsp$useOptContrib <- makeLogical(bsp$useOptContrib)
  bsp$phenoF1toStage1 <- makeLogical(bsp$useOptContrib)

  # In case the function is referred by name, replace with actual function
  if (length(bsp$selCritPipeAdv) == 0) bsp$selCritPipeAdv <- selCritIID
  if (length(bsp$selCritPopImprov) == 0) bsp$selCritPopImprov <- selCritIID
  if ("character" %in% class(bsp$selCritPipeAdv))
    bsp$selCritPipeAdv <- get(bsp$selCritPipeAdv)
  if ("character" %in% class(bsp$selCritPopImprov))
    bsp$selCritPopImprov <- get(bsp$selCritPopImprov)
  
  # Make sure you keep enough cycles
  bsp$nCyclesToKeepRecords <- max(bsp$nStages+1, bsp$nCyclesToKeepRecords)
  
  # Stop and warn user if not enough crosses specified
  if((bsp$nCrosses * bsp$nProgeny) < bsp$nEntries[1]){
    stop("Not enough F1s to fill up Stage 1 trial. [nCrosses * nProgeny >= nEntries for Stage 1] is required")
  }
  
  # Stop and warn user if stageToGenotype is not a named stage
  if (length(bsp$stageToGenotype)==0) bsp$stageToGenotype <- "SDN"
  if (!(bsp$stageToGenotype %in% c("F1", bsp$stageNames))){
      stop("The stageToGenotype is not one of the pipeline stages")
  }
  
  # Figure out how many checks to add to each stage
  pairwiseComp <- function(vec1, vec2, fnc){
    return(apply(cbind(vec1, vec2), 1, fnc))
  }
  if (is.null(bsp$entryToChkRatio)) bsp$entryToChkRatio <- integer(bsp$nStages)
  nPlots <- bsp$nEntries * bsp$nReps
  nChkPlots <- nPlots / bsp$entryToChkRatio
  nChkPlots <- pairwiseComp(nChkPlots, bsp$nReps, max) # At least one check / rep
  chkReps <- ceiling(nChkPlots / bsp$nChks)
  # Safety if nChks or entryToChkRatio misunderstood
  bsp$nChks <- if_else(bsp$entryToChkRatio == 0, 0, bsp$nChks)
  chkReps <- if_else(is.infinite(chkReps) | is.nan(chkReps) | is.na(chkReps), 0, chkReps)
  
  # Enforce other defaults
  if (bsp$useOptContrib){
    if (length(bsp$nCandOptCont) == 0) bsp$nCandOptCont <- min(bsp$nEntries[1], bsp$nParents*10)
    if (length(bsp$targetEffPopSize) == 0) bsp$targetEffPopSize <- bsp$nParents
  }
  if (bsp$phenoF1toStage1){
    if (length(bsp$errVarPreStage1) == 0) bsp$errVarPreStage1 <- bsp$genVar * 20
  }
  if (length(bsp$nCyclesToKeepRecords) == 0) bsp$nCyclesToKeepRecords <- 5
  
  # Defaults for GxE variance
  if (any(is.null(bsp$gxyVar), is.null(bsp$gxlVar), is.null(bsp$gxyxlVar))){
    if (!is.null(bsp$gxeVar)){
      if (is.null(bsp$gxyVar)) bsp$gxyVar <- bsp$gxeVar / 3
      if (is.null(bsp$gxlVar)) bsp$gxlVar <- bsp$gxeVar / 3
      if (is.null(bsp$gxyxlVar)) bsp$gxyxlVar <- bsp$gxeVar / 3
    } else{
      if (is.null(bsp$gxyVar)) bsp$gxyVar <- 0
      if (is.null(bsp$gxlVar)) bsp$gxlVar <- 0
      if (is.null(bsp$gxyxlVar)) bsp$gxyxlVar <- 0
    }
  }

  # Make sure everything has names
  names(bsp$nEntries) <- names(bsp$nChks) <- names(bsp$nReps) <- names(bsp$nLocs) <- names(bsp$errVars) <- names(chkReps) <- names(bsp$entryToChkRatio) <- bsp$stageNames
  bsp <- c(bsp, list(chkReps=chkReps), list(checks=NULL))
  return(bsp)
}

#' adjustBudget function
#'
#' Function to call once you have fully specified the costs but you want to adjust the size of the different stages so that the overall scheme budget matches some value.
#'
#' @param bsp A list of objects to combine with the species and population parameters. bsp is short for breeding sheme parameters
#' @param targetBudget Numeric value that you want the budget adjusted to
#' @param targetStages Character vector with stage names to be changed such that they become bigger or smaller to achieve the target budget
#' 
#' @return A revised bsp with the sizes of the target stages changed to match.
#'
#' @details Call this function after running specifyCosts.
#'
#' @examples
#' bsp <- adjustBudget(bsp, targetBudget=50000, targetStages=c("CET", "AYT", "UYT"))
#'
#' @export
adjustBudget <- function(bsp, targetBudget, targetStages){
  budgDiff <- (targetBudget - bsp$totalCosts) / length(targetStages)
  for (stage in targetStages){
    costPerInd <- bsp$nReps[stage] * bsp$nLocs[stage] * bsp$plotCost[stage] * (1 + 1 / bsp$entryToChkRatio[stage])
    if (stage == bsp$stageToGenotype){
        costPerInd <- costPerInd + bsp$qcGenoCost + bsp$wholeGenomeCost
    }
    chngEntries <- floor(budgDiff / costPerInd)
    nEntriesNow <- bsp$nEntries[stage] + chngEntries
    if (nEntriesNow < 0) stop("adjustBudget: trying to decrease budget too much")
    bsp$nEntries[stage] <- nEntriesNow
  }
  
  # Rerun through this to make sure checks numbers are right
  pairwiseComp <- function(vec1, vec2, fnc){
    return(apply(cbind(vec1, vec2), 1, fnc))
  }
  nPlots <- bsp$nEntries * bsp$nReps
  nChkPlots <- nPlots / bsp$entryToChkRatio
  nChkPlots <- pairwiseComp(nChkPlots, bsp$nReps, max) # At least one check / rep
  chkReps <- ceiling(nChkPlots / bsp$nChks)
  # Safety if nChks or entryToChkRatio misunderstood
  bsp$nChks <- if_else(bsp$entryToChkRatio == 0, 0, bsp$nChks)
  chkReps <- if_else(is.infinite(chkReps) | is.nan(chkReps) | is.na(chkReps), 0, chkReps)
  bsp$chkReps <- chkReps
  
  if (is.null(bsp$stageToGenotype) | bsp$stageToGenotype == "F1"){
    nGeno <- bsp$nCrosses * bsp$nProgeny
  } else{
    nGeno <- bsp$nEntries[bsp$stageToGenotype]
  }
  bsp$genotypingCosts <- nGeno * (bsp$qcGenoCost + bsp$wholeGenomeCost)
  
  bsp$trialCosts <- ((bsp$nEntries * bsp$nReps + bsp$nChks * bsp$chkReps) * bsp$nLocs) %*% bsp$plotCost
  
  bsp$totalCosts <- bsp$develCosts + bsp$genotypingCosts + bsp$trialCosts + bsp$locationCosts
  return(bsp)
}

#' function to read a text control file
#'
#' The text file should be organized as follows
#' 1. Any text after a comment symbol # will be ignored
#' 2. Control parameter names should be on their own line
#' 3. Parameter values should be on the following line. If multiple parameter values are needed they should be separated by white space but on the same line
#' @param fileName The name of the text file to be read. Must include the path to the file
#' @param parmNames A string vector with the names of the control parameters that will be searched in the text file
#' @return A named list of the parameter values read from the control file
#'
#' @details Call this function before beginning the simulation
#'
#' @examples
#' params <- readControlFile("./inputDir/ctrlFile.txt", c("nStages", "nParents", "nCrosses"))
#'
#' @export
readControlFile <- function(fileName, parmNames){
  ctrlLines <- readLines(fileName)
  ctrlLines <- sapply(ctrlLines, function(st) strsplit(st, "#", fixed=T)[[1]][1])
  getParm <- function(parmName){
    parmRow <- grep(parmName, ctrlLines)+1
    parms <- unlist(strsplit(ctrlLines[parmRow], "[[:space:]]"))
    names(parms) <- NULL
    parmsNum <- suppressWarnings(as.numeric(parms))
    if (!any(is.na(parmsNum))) parms <- parmsNum
    return(parms)
  }
  parms <- lapply(parmNames, getParm)
  names(parms) <- parmNames
  return(parms)
}
